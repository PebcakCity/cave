1. Changed IHasDebugInfo interface to IDebuggable and added methods for listing
available device methods and executing arbitrary methods by name.  Need to write
the parser that reads and executes the commands and add the UI bits to the glade
file (then finally get around to doing the rest of the things in this todo list)

The idea is to have a textbox in the DisplayTester app that allows one to enter
a method to execute with the params, then have the app parse this string and
execute it, so we can have a sort of "debugging session" with a device.  This
theoretically lets us have any number of callable methods that troubleshoot
devices without having a dedicated button for each and every one.  Eg. the
ClearCache method I added for RokuTV.  We don't want a button for this because
we don't want to accidentally press it.  It's for resetting the app cache to fix
a misbehaving app. (Such as DisneyPlus repeatedly giving me an error code 73
when I'm located in the US and not using a VPN... I had to look up how to clear
the cache, then delete the app, then restart the TV and readd the app to fix it)

--

2. Clean up the controllers...

--

3. Clean up the apps...

--

4. Implement a configuration file/database reader system for the RPi apps.

Figure out a data structure for storing multiple devices and a set of
"inputs" or instruction sequences that will cause different inputs to be
selected on multiple devices. Eg. To use a laptop, select input RGB 1 on the
projector and input 2 on the switcher.  To use the Apple TV, just select
input HDMI 1 on the projector.  These buttons are what we would ideally like
to be able to display on some sort of "Home screen", along with buttons for
system on / system off.
...

Sources : { 
    "PC": [
        "Projector": "RGB1",
        "AV switcher": "Input1"
    ],
    "Laptop": [
        "Projector": "RGB1",
        "AV switcher": "Input2"
    ],
    "Apple TV": [
        "Projector": "HDMI1"
    ]
}

Dictionary<string, List<KeyValuePair<string, string>>>

Devices : {
    "Projector" -> {Projector instance},
    "AV switcher" -> {Switcher instance}
}

Dictionary<string, Device>

So we need a data structure to keep all this data in that can be queried at
time of a click event on a button.  We read all the config data in and make it
available to all components (singleton service?) or just the HomePage component?

In the HomePage component, we use @foreach to create buttons with text matching
their source names and their @onclick is set to "@(() => SelectSource({text}))"

SelectSource uses the button text to index into the Sources collection to get
the list of KeyValuePairs, and then for each KeyValuePair in the List, we
use the Key to index into the Devices collection to retrieve the actual Device
instance, then check its interface and call the appropriate method to select
input.

Device GetDevice(string deviceName)
{
    Device device;
    if ( deviceName != null )
        device = Devices.GetValueOrDefault(deviceName);
    return device;
}

async Task SelectSource(string sourceName)
{
    try
    {
        var deviceInputList = Sources.GetValueOrDefault(sourceName);
        foreach ( var deviceInput in deviceInputList )
        {
            Device device = GetDevice(deviceInput.Key);
            if ( device is IDisplayInputSelectable idis )
                await idis.PowerOnSelectInput(deviceInput.Value);
            else if ( device is IInputSelectable iis )
                await iis.SelectInput(deviceInput.Value);
                
            if ( device is IDisplayMutable idm )
                idm.DisplayMute(false);
        }
    }
    catch ( Exception ex )
    {
        throw;
    }
}

--

5. I may want to change Projector.InputsAvailable and its matching
field in Television to be a Dictionary<string,string>.  This would allow a
button to receive a "friendly name" to display, while the other string is the
actual enumeration member name that corresponds to the input.  If I get the
HomePage component worked out, then this might not be a big deal.  I had
originally planned to have the "friendly names" appear on the HomePage like
"Apple TV", etc. The DeviceController page was just going to show the actual
input name. But it's all the same I suppose.  Maybe it wouldn't hurt to have
the option?

Side note: It might be useful to have a boolean flag for whether a device gets
its own dedicated control page or not?  That's something to think about later.


-------------------------------

Things I'm trying to figure out:

With the Blazor server app, how can we pass a list (or dictionary) of input
names to a DeviceController component?  There are several ways to pass data from
one component to another:
Route parameters, query strings, component parameters, state containers...
The best fit is probably to use a mix of component parameters and a singleton
service that contains the whole configuration.  Config would get loaded and be
available to the HomePage so it would have a reference to each Device for
SelectSource to use.

Component parameters:

[Index page]

@for( int i = 0; i < DeviceList.Count; i++ )
{
    <DeviceController Device="@DeviceList[i]"/>
}

@code
{
    // get list of devices
    List<Device> DeviceList = ...
}

[DeviceController page]

@code
{
    [Parameter]
    public Device Device { get; set; }
}

-----

Singleton Service

[Program.cs]

builder.Services.AddSingleton<AppConfig>();

[Shared/AppConfig.cs]

public class AppConfig
{
    public string RoomName {get; protected set;}
    public Dictionary<string, Device> Devices {get; protected set;}
    public Dictionary<string, List<KeyValuePair>>> Sources {get; protected set;}
    //...
}

[Component]
@inject AppConfig appConfig;

...

-----------------------------------------------

Other things to do / things to work on for fun:

- Read up on various things: generics, delegates, etc

