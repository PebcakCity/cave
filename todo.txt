1. I implemented a rather crappy mechanism (GetStatus(bool appWantsText)) for
allowing an app to force a controller to get updated state information from a
device and then send a text summary of it to the app for displaying in a
text view.  I'm not too happy with it.  I don't like the idea of taking what
was essentially a private business logic method (GetStatus) and making it
public so that it can serve another purpose and be called by an app for
updating the UI.  So I think I'm going to move GetStatus back to being private
(and maybe rename it something more like UpdateStatus?)  Then I'll create a
separate interface method for IDisplay (or maybe the abstract Device class
itself) called GetStatusText/GetStatusString/GetDebugInfo or whatever that
would get the device's current state, build that wall of text with it and
return it to the app for display.  GetDebugInfo sounds like the best name
for it.  I guess it could return _all_ the information we have about the
device and its Status.

--

2. Clean up the controllers...

--

3. Clean up the apps...

--

4. Implement a configuration file/database reader system for the RPi apps.

Figure out a data structure for storing multiple devices and a set of
"inputs" or instruction sequences that will cause different inputs to be
selected on multiple devices. Eg. To use a laptop, select input RGB 1 on the
projector and input 2 on the switcher.  To use the Apple TV, just select
input HDMI 1 on the projector.  These buttons are what we would ideally like
to be able to display on some sort of "Home screen", along with buttons for
system on / system off.
...

Sources : { 
    "PC": [
        "Projector": "RGB1",
        "AV switcher": "Input1"
    ],
    "Laptop": [
        "Projector": "RGB1",
        "AV switcher": "Input2"
    ],
    "Apple TV": [
        "Projector": "HDMI1"
    ]
}

Dictionary<string, List<KeyValuePair<string, string>>>

Devices : {
    "Projector" -> {Projector instance},
    "AV switcher" -> {Switcher instance}
}

Dictionary<string, Device>

So we need a data structure to keep all this data in that can be queried at
time of a click event on a button.  We read all the config data in and make it
available to all components (singleton service?) or just the HomePage component?

In the HomePage component, we use @foreach to create buttons with text matching
their source names and their @onclick is set to "@(() => SelectSource({text}))"

SelectSource uses the button text to index into the Sources collection to get
the list of KeyValuePairs, and then for each KeyValuePair in the List, we
use the Key to index into the Devices collection to retrieve the actual Device
instance, then check its interface and call the appropriate method to select input.

Device GetDevice(string deviceName)
{
    Device device;
    if ( deviceName != null )
        device = Devices.GetValueOrDefault(deviceName);
    return device;
}

async Task SelectSource(string sourceName)
{
    try
    {
        var deviceInputList = Sources.GetValueOrDefault(sourceName);
        foreach ( var deviceInput in deviceInputList )
        {
            Device device = GetDevice(deviceInput.Key);
            if ( device is IDisplayInputSelectable idis )
                await idis.PowerOnSelectInput(deviceInput.Value);
            else if ( device is IInputSelectable iis )
                await iis.SelectInput(deviceInput.Value);
                
            if ( device is IDisplayMutable idm )
                idm.DisplayMute(false);
        }
    }
    catch ( Exception ex )
    {
        throw;
    }
}

--

5. I may want to change Projector.InputsAvailable and its matching
field in Television to be a Dictionary<string,string>.  This would allow a button
to receive a "friendly name" to display, while the other string is the actual
enumeration member name that corresponds to the input.  If I get the HomePage
component worked out, then this might not be a big deal.  I had originally planned
to have the "friendly names" appear on the HomePage like "Apple TV", etc.
The DeviceController page was just going to show the actual input name.
But it's all the same I suppose.  Maybe it wouldn't hurt to have the option?

Side note: It might be useful to have a boolean flag for whether a device gets
its own dedicated control page or not?  That's something to think about later.


-------------------------------

Things I'm trying to figure out:

With the Blazor server app, how can we pass a list (or dictionary) of input
names to a DeviceController component?  There are several ways to pass data from
one component to another:
Route parameters, query strings, component parameters, state containers...
The best fit is probably to use a mix of component parameters and a singleton
service that contains the whole configuration.  Config would get loaded and be
available to the HomePage so it would have a reference to each Device for
SelectSource to use.

Component parameters:

[Index page]

@for( int i = 0; i < DeviceList.Count; i++ )
{
    <DeviceController Device="@DeviceList[i]"/>
}

@code
{
    // get list of devices
    List<Device> DeviceList = ...
}

[DeviceController page]

@code
{
    [Parameter]
    public Device Device { get; set; }
}

-----

Singleton Service

[Program.cs]

builder.Services.AddSingleton<AppConfig>();

[Shared/AppConfig.cs]

public class AppConfig
{
    public string RoomName {get; protected set;}
    public Dictionary<string, Device> Devices {get; protected set;}
    public Dictionary<string, List<KeyValuePair>>> Sources {get; protected set;}
    //...
}

[Component]
@inject AppConfig appConfig;

...

-----------------------------------------------

Other things to do / things to work on for fun:

- Read up on various things: generics, delegates, etc

