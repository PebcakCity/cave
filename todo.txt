- Rework exception system.  Poor exception handling is losing stack trace
info & it's ugly all around.


- Implement a configuration file/database reader system for the RPi apps.

Figure out a data structure for storing multiple devices and a set of
"inputs" or instruction sequences that will cause different inputs to be
selected on multiple devices. Eg. To use a laptop, select input RGB 1 on the
projector and input 2 on the switcher.  To use the Apple TV, just select
input HDMI 1 on the projector.  These buttons are what we would ideally like
to be able to display on some sort of "Home screen", along with buttons for
system on / system off.
...

Sources : { 
    "PC": [
        "Projector": "RGB1",
        "AV switcher": "Input1"
    ],
    "Laptop": [
        "Projector": "RGB1",
        "AV switcher": "Input2"
    ],
    "Apple TV": [
        "Projector": "HDMI1"
    ]
}

Dictionary<string, List<KeyValuePair<string, string>>>

Devices : {
    "Projector" -> {Projector instance},
    "AV switcher" -> {Switcher instance}
}

Dictionary<string, Device>

So we need a data structure to keep all this data in that can be queried at
time of a click event on a button.  We read all the config data in and make it
available to all components (singleton service?) or just the HomePage component?

In the HomePage component, we use @foreach to create buttons with text matching
their source names and their @onclick is set to "@(() => SelectSource({text}))"

SelectSource uses the button text to index into the Sources collection to get
the list of KeyValuePairs, and then for each KeyValuePair in the List, we
use the Key to index into the Devices collection to retrieve the actual Device
instance, then check its interface and call the appropriate method to select
input.

Device GetDevice(string deviceName)
{
    Device device;
    if ( deviceName != null )
        device = Devices.GetValueOrDefault(deviceName);
    return device;
}

async Task SelectSource(string sourceName)
{
    try
    {
        var deviceInputList = Sources.GetValueOrDefault(sourceName);
        foreach ( var deviceInput in deviceInputList )
        {
            Device device = GetDevice(deviceInput.Key);
            if ( device is IDisplayInputSelectable idis )
                await idis.PowerOnSelectInput(deviceInput.Value);
            else if ( device is IInputSelectable iis )
                await iis.SelectInput(deviceInput.Value);
                
            if ( device is IDisplayMutable idm )
                idm.DisplayMute(false);
        }
    }
    catch ( Exception ex )
    {
        throw;
    }
}

-------------------------------

Things in the back of my mind:

With the Blazor server app, how can we pass a list (or dictionary) of input
names to a DeviceController component?  There are several ways to pass data from
one component to another:
Route parameters, query strings, component parameters, state containers...
The best fit is probably to use a mix of component parameters and a singleton
service that contains the whole configuration.  Config would get loaded and be
available to the HomePage so it would have a reference to each Device for
SelectSource to use.

Component parameters:

[Index page]

@for( int i = 0; i < DeviceList.Count; i++ )
{
    <DeviceController Device="@DeviceList[i]"/>
}

@code
{
    // get list of devices
    List<Device> DeviceList = ...
}

[DeviceController page]

@code
{
    [Parameter]
    public Device Device { get; set; }
}

-----

Singleton Service

[Program.cs]

builder.Services.AddSingleton<AppConfig>();

[Shared/AppConfig.cs]

public class AppConfig
{
    public string RoomName {get; protected set;}
    public Dictionary<string, Device> Devices {get; protected set;}
    public Dictionary<string, List<KeyValuePair>>> Sources {get; protected set;}
    //...
}

[Component]
@inject AppConfig appConfig;

...
